import { PublishSubscribeState } from './PublishSubscribeState';
import { Devices } from './types';
export interface UneeqMessage {
    uneeqMessageType: UneeqMessageType;
}
export declare enum UneeqMessageType {
    Ready = "Ready",
    DeviceNotFoundError = "DeviceNotFoundError",
    SetCameraSuccess = "SetCameraSuccess",
    SetMicSuccess = "SetMicSuccess",
    SetSpeakerSuccess = "SetSpeakerSuccess",
    SessionPaused = "SessionPaused",
    SessionResumed = "SessionResumed",
    SessionEnded = "SessionEnded",
    AvatarAvailable = "AvatarAvailable",
    AvatarUnavailable = "AvatarUnavailable",
    ConnectionLost = "ConnectionLost",
    ServiceUnavailable = "ServiceUnavailable",
    OnlineStatusUpdate = "OnlineStatusUpdate",
    MicActivityNotSupported = "MicActivityNotSupported",
    MicActivityError = "MicActivityError",
    MicActivity = "MicActivity",
    DeviceError = "DeviceError",
    DeviceListUpdated = "DeviceListUpdated",
    AvatarAnswer = "AvatarAnswer",
    AvatarAnswerContent = "AvatarAnswerContent",
    AvatarTextInputFinished = "AvatarTextInputFinished",
    AvatarQuestionText = "AvatarQuestionText",
    DevicePermissionAllowed = "DevicePermissionAllowed",
    RecordingStarted = "RecordingStarted",
    RecordingStopped = "RecordingStopped",
    Warning = "Warning",
    SessionLive = "SessionLive",
    WebRtcData = "WebRtcData",
    WebRtcStats = "WebRtcStats",
    SessionError = "SessionError",
    ClientMediaStreamUpdate = "ClientMediaStreamUpdate"
}
/**
 * Service is ready to be used
 */
export declare class ReadyMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Selected device is not found
 */
export declare class DeviceNotFoundErrorMessage implements UneeqMessage {
    readonly msg: string;
    readonly deviceId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(msg: string, deviceId: string);
}
/**
 * Users camera has been set successfully
 */
export declare class SetCameraSuccessMessage implements UneeqMessage {
    readonly deviceId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(deviceId: string);
}
/**
 * Users microphone has been set successfully
 */
export declare class SetMicSuccessMessage implements UneeqMessage {
    readonly deviceId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(deviceId: string);
}
/**
 * Users speaker has been set successfully
 */
export declare class SetSpeakerSuccessMessage implements UneeqMessage {
    readonly deviceId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(deviceId: string);
}
/**
 * An error has occured with the users device
 */
export declare class DeviceErrorMessage implements UneeqMessage {
    readonly error: Error;
    uneeqMessageType: UneeqMessageType;
    constructor(error: Error);
}
/**
 * The device list has been changed or retrieved for the first time
 */
export declare class DeviceListUpdatedMessage implements UneeqMessage {
    readonly devices: Devices;
    uneeqMessageType: UneeqMessageType;
    constructor(devices: Devices);
}
/**
 * Session has been paused successfully
 */
export declare class SessionPausedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Session has been resumed successfully
 */
export declare class SessionResumedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Session has been ended successfully
 */
export declare class SessionEndedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * An avatar is available
 */
export declare class AvatarAvailableMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * There are no avatars currently available
 */
export declare class AvatarUnavailableMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Service is unavailable
 */
export declare class ServiceUnavailableMessage implements UneeqMessage {
    readonly error: any;
    uneeqMessageType: UneeqMessageType;
    constructor(error: any);
}
/**
 * An error occured with mic activity messages
 */
export declare class MicActivityErrorMessage implements UneeqMessage {
    readonly error: Error;
    uneeqMessageType: UneeqMessageType;
    constructor(error: Error);
}
/**
 * Message is sent upon activity of the user microphone
 */
export declare class MicActivityMessage implements UneeqMessage {
    readonly level: number;
    uneeqMessageType: UneeqMessageType;
    constructor(level: number);
}
/**
 * Mic activity messages are not supported by the users browser
 */
export declare class MicActivityNotSupportedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Connection Lost
 */
export declare class ConnectionLostMessage implements UneeqMessage {
    readonly connectionState: PublishSubscribeState;
    uneeqMessageType: UneeqMessageType;
    constructor(connectionState: PublishSubscribeState);
}
/**
 * The avatar's answer to a question
 */
export declare class AvatarAnswerMessage implements UneeqMessage {
    readonly answer: string;
    readonly answerAvatar: string;
    readonly answerSpeech: string;
    uneeqMessageType: UneeqMessageType;
    constructor(answer: string, answerAvatar: string, answerSpeech: string);
}
/**
 * The avatar's answer to a question (HTML Content)
 */
export declare class AvatarAnswerContentMessage implements UneeqMessage {
    readonly content: string;
    uneeqMessageType: UneeqMessageType;
    constructor(content: string);
}
/**
 * The question the user asked
 */
export declare class AvatarQuestionMessage implements UneeqMessage {
    readonly question: any;
    uneeqMessageType: UneeqMessageType;
    constructor(question: any);
}
/**
 * Avatar has finished speaking the message
 */
export declare class AvatarTextInputFinishedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * User has given permission to use devices
 */
export declare class DevicePermissionAllowedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * User has started a recording successfully
 */
export declare class RecordingStartedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * User has stopped recording successfully
 */
export declare class RecordingStoppedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * General Warning Message - refer to msg
 */
export declare class WarningMessage implements UneeqMessage {
    readonly msg: string;
    uneeqMessageType: UneeqMessageType;
    constructor(msg: string);
}
/**
 * Session is Live, avatar video is active
 */
export declare class SessionLiveMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * WebRTC data channel message
 */
export declare class WebRtcDataMessage implements UneeqMessage {
    readonly data: any;
    uneeqMessageType: UneeqMessageType;
    constructor(data: any);
}
/**
 * WebRTC stats message (diagnostics)
 */
export declare class WebRtcStatsMessage implements UneeqMessage {
    readonly stats: any;
    uneeqMessageType: UneeqMessageType;
    constructor(stats: any);
}
/**
 * Session Error has occurred
 */
export declare class SessionErrorMessage implements UneeqMessage {
    readonly error: string;
    uneeqMessageType: UneeqMessageType;
    constructor(error: string);
}
/**
 * Clients network status has changed. {online: true|false}
 */
export declare class OnlineStatusUpdateMessage implements UneeqMessage {
    readonly online: boolean;
    uneeqMessageType: UneeqMessageType;
    constructor(online: boolean);
}
export declare class ClientMediaStreamUpdateMessage implements UneeqMessage {
    readonly clientStreamingAudio: boolean;
    readonly clientStreamingVideo: boolean;
    readonly serverStreamingAudio: boolean;
    readonly serverStreamingVideo: boolean;
    uneeqMessageType: UneeqMessageType;
    constructor(clientStreamingAudio: boolean, clientStreamingVideo: boolean, serverStreamingAudio: boolean, serverStreamingVideo: boolean);
}
